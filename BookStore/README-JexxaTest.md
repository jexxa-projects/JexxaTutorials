# BookStore - Writing Tests

## What You Learn
   
*   [How to write unit tests for your aggregates](#Write-unit-tests-for-aggregates)
*   [How to write test using stubs](#Write-tests-using-stubs)
*   [How to write integration tests](#Write-integration-tests)

## What you need

*   Understand tutorial [`BookStore - Using a Repository`](README.md)
*   Writing tests with JUnit
*   45 minutes
*   JDK 17 (or higher) installed
*   Maven 3.6 (or higher) installed

## General Note

When writing tests for a business application, we recommend the following three types of tests:
  
*   Unit tests: In general, you should write pure unit tests as much as possible, especially for your aggregates. This ensures that your business tests remain independent of any technology. In addition, you avoid the anti-pattern `anemic model` and accidentally put business logic into an application- or domain service. For these tests, you need JUnit. 

*   Stub tests: Sometimes, it is necessary to test an application or domain service that requires a technology stack, such as a `Repository`.  In this case, we recommend using stubs instead of mocks. The reason for this is that mock tests can lead to validating execution steps within the domain core instead of the domain-specific use cases. Therefore, `jexxa-test` automatically provides stubs for all your driven adapters if you use Jexxa's driven adapter strategies.

*   Integration tests: Finally, you should provide at least some integration tests that are executed against your running application. `jexxa-test` supports this by providing convenience classes based on the conventions of Jexxa. 

For all tests, we use the arrange-act-assert pattern because it forces tests to focus on independent, 
individual behaviors. As soon as you want to use module `jexxa-test`, you have to add the following dependency (check that you use the latest version).

```xml
    <dependency>
      <groupId>io.jexxa.jexxatest</groupId>
      <artifactId>jexxa-test</artifactId>
      <version>8.1.11</version>
      <scope>test</scope>
    </dependency>
```

## Write Unit Tests for Aggregates

 A simple example of unit-tests for the aggregate
`Book` can be found [here](src/test/java/io/jexxa/tutorials/bookstore/domain/book/BookTest.java).

In the following example, we show how to validate DomainEvents generated by the aggregate.
For this purpose, we add a class `DomainEventRecorder` that subscribes either to a specific
or to all domain events. In the `Arrange` step, we first create an instance of this class and register it 
by the [`DomainEventPublisher`](src/main/java/io/jexxa/tutorials/bookstore/domain/DomainEventPublisher.java) which is part of our domain. In the `Assert` step we can then validate the sending of expected domain events.  

The complete test class can be found [here](src/test/java/io/jexxa/tutorials/bookstore/domain/book/BookTest.java).

```java
class BookTest { 
    @Test
    void sellLastBook() {
        // Arrange
        var amountInStock = 1;
        var domainEventRecorder = new DomainEventRecorder();
        subscribe(BookSoldOut.class, domainEventRecorder::receive);

        var objectUnderTest = newBook(ANY_BOOK);
        objectUnderTest.addToStock(amountInStock);

        // Act / Assert
        assertDoesNotThrow(objectUnderTest::sell);

        // Assert
        assertEquals(0, objectUnderTest.amountInStock() );
        assertEquals(1, domainEventRecorder.getDomainEvents().size() );
    }

    private static class DomainEventRecorder {
        private final List<BookSoldOut> domainEvents = new ArrayList<>();

        public void receive(BookSoldOut bookSoldOut) {
            domainEvents.add(bookSoldOut);
        }

        List<BookSoldOut> getDomainEvents()  {
            return domainEvents;
        }
    }
}
```

## Write Tests using Stubs

Writing some stub tests with Jexxa is quite easy. The main difference to a pure unit test is the initialization phase for each test.

The complete test class can be found [here](src/test/java/io/jexxa/tutorials/bookstore/applicationservice/BookStoreServiceTest.java).


### Initialize the tests 

As a first step, you initialize your tests by calling `initTest()` by annotating it with `@BeforeEach`: 
*    Create a JexxaTest before each test 
*    Initialize and request all objects you need for testing and validation 
*    Bootstrap all services as in your main method to ensure the same initial setup as you start your application

```java
class BookStoreServiceTest
{
    private static final ISBN13 ANY_BOOK = createISBN("978-3-86490-387-8");

    private BookStoreService objectUnderTest;       // Object we want to test
    private MessageRecorder  publishedDomainEvents; // Message recorder to validate published DomainEvents
    private BookRepository   bookRepository;        // Repository to validate results in the tests
    
    @BeforeEach
    void initTest()
    {
        // JexxaTest is created for each test. It provides stubs for running your tests so that no
        // mock framework is required. It expects the class name your application!
        JexxaTest jexxaTest = getJexxaTest(BookStore.class);

        // Request the objects needed for our tests
        objectUnderTest       = jexxaTest.getInstanceOfPort(BookStoreService.class);   // 1. We need the object we want to test
        publishedDomainEvents = jexxaTest.getMessageRecorder(DomainEventSender.class); // 2. A recorder for DomainEvents published via DomainEventSender
        bookRepository        = jexxaTest.getRepository(BookRepository.class);         // 3. Repository managing all books

        // Invoke all bootstrapping services from the main method to ensure the same starting point
        jexxaTest.getJexxaMain().bootstrapAnnotation(DomainService.class);
    }

    //...
}
```

### Test: Sell last book
In the following sample, you see that your tests can then be written quite similarly to pure unit tests.
```java
class BookStoreServiceTest 
{
   // ... initialization of tests

    @Test
    void sellLastBook() 
    {
        //Arrange
        objectUnderTest.addToStock(ANY_BOOK, 1);

        // Act / Assert
        assertDoesNotThrow(() -> objectUnderTest.sell(ANY_BOOK));
        
        //Assert
        assertEquals( 0 , objectUnderTest.amountInStock(ANY_BOOK) );                        // Perform assertion against the object we test
        assertEquals( 1 , publishedDomainEvents.size() );                                   // Perform assertion against the repository
        assertEquals( bookSoldOut(ANY_BOOK), publishedDomainEvents.getMessage(BookSoldOut.class));  // Perform assertion against published DomainEvents
    }

}
```
## Write Integration Tests

Finally, we show how to write integration tests. In this case, we assume that your application is started on your local machine. In all our tutorials and templates, maven does this before running the integration tests.


### Initialize and shutdown the IT-tests

In the following you see how to initialize and shutdown class `JexxaIntegrationTest` which is the starting point for your integration test. From this class you request:
*    A `RESTBinding` to access your running application via `RESTFulRCPAdapter`
*    A `JMSBinding` to access application under test via JMS  


```java
class BookstoreIT {
    // ... initialization of additional parameters for your tests

    private static JexxaIntegrationTest jexxaIntegrationTest;  // Simplified IT testing with jexxa-test
    private static RESTBinding restBinding;                    // Binding to access the application under test via REST
    private static MessageBinding messageBinding;              // Binding to access application under test via JMS

    @BeforeAll
    static void initBeforeAll() {
        jexxaIntegrationTest = new JexxaIntegrationTest(BookStore.class);
        messageBinding = jexxaIntegrationTest.getMessageBinding();
        restBinding = jexxaIntegrationTest.getRESTBinding();
    }
    
    // Add your tests here 

    @AfterAll
    static void shutDown()
    {
        jexxaIntegrationTest.shutDown();
    }
}    
```


### Test: Sell last book
In the following test, you see how to use the `RESTBinding` to access your application. Please note that we cannot directly perform a method call since we send a REST call. 

But similar to a method call, we provide all parameters: Return value `Void.class`, method name `addToStock` and the two parameters `ANY_BOOK, 5`
```java
        bookStoreService.postRequest(Void.class, addToStock, ANY_BOOK, 5);
```
The JMSBinding provides the possibility to send and receive messages. 
The complete test looks as follows. The complete test can be found [here](src/test/java/io/jexxa/tutorials/bookstore/integration/BookstoreIT.java)

```java
class BookstoreIT {
    // ... initialization of the test  
    @Test
    void testSellLastBook() {
        //Arrange
        var bookStoreService = restBinding.getRESTHandler(BookStoreService.class);
        var messageListener = messageBinding.getMessageListener("BookStoreTopic", JMSConfiguration.MessagingType.TOPIC);
    
        bookStoreService.postRequest(Void.class, addToStock, ANY_BOOK, 5);
        var inStock = bookStoreService.postRequest(Integer.class, amountInStock, ANY_BOOK );

        //Act - Sell all books in stock
        for (int i = 0; i < inStock; ++i)
        {
            bookStoreService.postRequest(Void.class, sell, ANY_BOOK);
        }

        // Receive the jms message
        var result = messageListener
                .awaitMessage(5, TimeUnit.SECONDS)
                .pop(BookSoldOut.class);

        //Assert
        assertEquals(BookSoldOut.bookSoldOut(ANY_BOOK), result);
    }
}
```
